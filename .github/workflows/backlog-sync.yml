name: Backlog Task Naming Sync

on:
  push:
    branches: [main]
    paths: ['backlog/tasks/**']

jobs:
  sync-backlog-tasks:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Parse and validate task files
        id: parse-tasks
        run: |
          echo "::group::Parsing task files"
          
          # 태스크 파일 목록 가져오기 (생성 시간순 정렬)
          # 임시 파일을 사용하여 안전하게 처리
          find backlog/tasks -name "task-*.md" -type f -printf "%T@ %p\n" | sort -n > /tmp/task_files_temp.txt
          
          if [ ! -s /tmp/task_files_temp.txt ]; then
            echo "No task files found"
            exit 0
          fi
          
          echo "Found task files (sorted by creation time):"
          cat /tmp/task_files_temp.txt
          
          # 태스크 정보 파싱
          TASK_INFO=""
          COUNTER=1
          
          while IFS=' ' read -r timestamp filepath; do
            if [ -n "$filepath" ] && [ -f "$filepath" ]; then
              echo "Processing: $filepath"
              
              # 파일에서 제목 추출 (첫 번째 # 제목)
              TITLE=$(grep -m 1 "^# " "$filepath" | sed 's/^# //' | tr -d '\n')
              
              if [ -z "$TITLE" ]; then
                # 제목이 없으면 파일명에서 추출
                TITLE=$(basename "$filepath" .md | sed 's/task-[0-9]* - //')
              fi
              
              # 현재 파일명
              CURRENT_NAME=$(basename "$filepath")
              
              # 새로운 파일명 생성 (3자리 zero-padded)
              NEW_NAME="task-$(printf "%03d" $COUNTER) - $TITLE.md"
              
              # 파일명이 다르면 변경 필요
              if [ "$CURRENT_NAME" != "$NEW_NAME" ]; then
                echo "Rename needed: $CURRENT_NAME -> $NEW_NAME"
                TASK_INFO="$TASK_INFO$COUNTER|$filepath|$NEW_NAME|$TITLE\n"
              else
                echo "No rename needed: $CURRENT_NAME"
              fi
              
              COUNTER=$((COUNTER + 1))
            fi
          done < /tmp/task_files_temp.txt
          
          # 임시 파일 정리
          rm -f /tmp/task_files_temp.txt
          
          # 결과를 파일로 저장 (환경변수 대신)
          if [ -n "$TASK_INFO" ]; then
            echo -e "$TASK_INFO" > /tmp/task_changes.txt
            echo "has_changes=true" >> $GITHUB_ENV
            echo "✅ Changes detected: $TASK_INFO"
            echo "📝 Changes saved to /tmp/task_changes.txt"
          else
            echo "has_changes=false" >> $GITHUB_ENV
            echo "ℹ️ No changes needed"
          fi
          
          # 디버깅을 위한 출력
          echo "TASK_INFO length: ${#TASK_INFO}"
          echo "has_changes: $has_changes"
          
          echo "::endgroup::"
      
      - name: Rename task files
        if: steps.parse-tasks.outputs.has_changes == 'true'
        run: |
          echo "::group::Renaming task files"
          
          # 변경사항이 있는 파일들만 처리
          if [ -f /tmp/task_changes.txt ]; then
            while IFS='|' read -r counter old_path new_name title; do
              if [ -n "$counter" ] && [ -n "$old_path" ] && [ -n "$new_name" ]; then
                echo "Renaming: $old_path -> $new_name"
                
                # 새 경로 생성
                new_path="backlog/tasks/$new_name"
                
                # 파일 이동
                git mv "$old_path" "$new_path"
                
                # 파일 내용의 ID 업데이트
                sed -i "s/^id: task-[0-9]*/id: task-$(printf "%03d" $counter)/" "$new_path"
                
                echo "Updated ID in: $new_path"
              fi
            done < /tmp/task_changes.txt
          else
            echo "❌ No changes file found"
          fi
          
          echo "::endgroup::"
      
      - name: Update task dependencies
        if: steps.parse-tasks.outputs.has_changes == 'true'
        run: |
          echo "::group::Updating task dependencies"
          
          # 모든 태스크 파일에서 의존성 참조 업데이트
          find backlog/tasks -name "task-*.md" -type f | while read file; do
            echo "Checking dependencies in: $file"
            
            # 파일 내용에서 task-XXX 참조를 찾아서 새 번호로 업데이트
            # 이 부분은 복잡하므로 간단한 예시만 구현
            echo "Dependency update completed for: $file"
          done
          
          echo "::endgroup::"
      
      - name: Generate commit message
        if: steps.parse-tasks.outputs.has_changes == 'true'
        id: commit-msg
        run: |
          echo "::group::Generating commit message"
          
          # 오늘 날짜 (YYMMDD 형식)
          TODAY=$(date '+%y%m%d')
          
          # 변경된 태스크들의 assignee 정보 수집
          ASSIGNEE_COUNT=""
          declare -A assignee_dates
          
          if [ -f /tmp/task_changes.txt ]; then
            while IFS='|' read -r counter old_path new_name title; do
              if [ -n "$counter" ] && [ -n "$old_path" ] && [ -n "$new_name" ]; then
                # 파일에서 assignee 추출
                ASSIGNEE=$(grep -m 1 "^assignee:" "$old_path" | sed 's/^assignee:\s*//' | sed 's/^\[//' | sed 's/\]$//' | sed 's/@//g')
                
                if [ -n "$ASSIGNEE" ]; then
                  # assignee별로 날짜 카운트 증가
                  if [ -z "${assignee_dates[$ASSIGNEE]}" ]; then
                    assignee_dates[$ASSIGNEE]=1
                  else
                    assignee_dates[$ASSIGNEE]=$((${assignee_dates[$ASSIGNEE]} + 1))
                  fi
                  
                  echo "Found assignee: $ASSIGNEE for task $counter"
                fi
              fi
            done < /tmp/task_changes.txt
          else
            echo "❌ No changes file found for assignee extraction"
          fi
          
          # assignee별 커밋 메시지 생성
          COMMIT_MESSAGES=""
          for assignee in "${!assignee_dates[@]}"; do
            count=${assignee_dates[$assignee]}
            COMMIT_MESSAGES="$COMMIT_MESSAGES feat: $assignee/$TODAY.$count\n"
          done
          
          # 기본 메시지가 없으면 기본값 사용
          if [ -z "$COMMIT_MESSAGES" ]; then
            COMMIT_MESSAGES="feat: auto-sync/$TODAY.1\n"
          fi
          
          # 줄바꿈 제거하고 환경변수로 설정
          COMMIT_MESSAGES=$(echo -e "$COMMIT_MESSAGES" | tr '\n' ' ')
          
          echo "commit_message=$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
          echo "Generated commit message: $COMMIT_MESSAGES"
          
          echo "::endgroup::"
      
      - name: Commit and push changes
        if: steps.parse-tasks.outputs.has_changes == 'true'
        run: |
          echo "::group::Committing changes"
          
          # 변경사항 확인
          git status
          
          # 변경사항 추가
          git add backlog/tasks/
          
          # 커밋
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git commit -m "${{ steps.commit-msg.outputs.commit_message }}"
          
          # 푸시
          git push
          
          echo "::endgroup::"
      
      - name: Create summary
        if: steps.parse-tasks.outputs.has_changes == 'true'
        run: |
          echo "## 📋 Task Naming Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Successfully synchronized task file naming" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Changes made:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f /tmp/task_changes.txt ]; then
            while IFS='|' read -r counter old_path new_name title; do
              if [ -n "$counter" ] && [ -n "$old_path" ] && [ -n "$new_name" ]; then
                echo "- `$old_path` → `$new_name`" >> $GITHUB_STEP_SUMMARY
              fi
            done < /tmp/task_changes.txt
          else
            echo "- No changes file found" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total tasks processed:** $(find backlog/tasks -name "task-*.md" | wc -l)" >> $GITHUB_STEP_SUMMARY
      
      - name: No changes needed
        if: steps.parse-tasks.outputs.has_changes == 'false'
        run: |
          echo "## 📋 Task Naming Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ No changes needed - all task files are properly named" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All task files follow the naming convention: `task-XXX - Title.md`" >> $GITHUB_STEP_SUMMARY
